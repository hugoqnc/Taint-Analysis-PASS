#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA)  // `var_cond_id` references the condition

// Jump from a block `id_block_from` to a different function with entry block
// `id_block_to` (i.e. a function call). The called function returns to the
// continuation block `id_continuation` of the caller function via return
// transfers.
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)

// Return transfer (note there is no target block; if needed, this can be
// inferred at call sites via the `id_continuation` of the jump transfer).
.decl return(id_transfer: Transfer, id_block_from: Block)

// List of arguments passed in a transfer
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)

// Ignore these...
//.decl arrayStore(id: SSA, id_array: SSA, id_index: SSA, id_var: SSA)
//.decl mapStore(id: SSA, id_map: SSA, id_key: SSA, id_var: SSA)
//.decl arrayLoad(id: SSA, id_array: SSA, id_index: SSA)
//.decl mapLoad(id: SSA, id_map: SSA, id_key: SSA)
//.decl call(id_transfer: Transfer, id_block_from: Block, id_block_to: Block, id_continuation: Block)
//.decl unknownBlock(id_block: Block)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable
// Ignore these...
//.input arrayLoad
//.input mapLoad
//.input arrayStore
//.input mapStore
//.input call
//.input unknownBlock
#endif


// Helper relations
.decl msgSender(id: SSA)
msgSender(id) :- builtinVariable(id, "SENDER").

//_________________________________________________________
// OUTPUT RELATIONS
//_________________________________________________________

.decl tainted_sinks(id: SSA)

// PART 1: find variables that depend on msg.sender
.decl derivesFrom(id_derived: SSA, id_taint: SSA) // independently of context, tells you if some variable depends on another through basic (explicit) operations or through implicit branching  
.decl contextSenderChain(new_ctxt: SSA, old_ctxt: SSA) // recursive dependencies of contexts
.decl blockChain(return_block: Block, entry_block: Block) // contains blocks that are linked by jump/branch/goto: it corresponds to chain of blocks linked by arrows on the --visualize schema
.decl containsSender(id_stmt: SSA, ctxt: SSA)

// .decl contextUntrustedVariablesChain(new_ctxt: SSA, old_ctxt: SSA) 
.decl allPossibleContexts(id_stmt: SSA, ctxt: SSA)

.decl trustedVariables(id: SSA, ctxt: SSA)
.decl untrustedVariables(id_stmt: SSA, ctxt: SSA)
.decl untrustedStateVariables(field: Name)
.decl validGuards(id: SSA, ctxt: SSA)
.decl trustedBlocks(id_block: Block, ctxt: SSA)
// .decl untrustedBlocks(id_block: Block, ctxt: SSA)

//_________________________________________________________
// LOGIC IMPLEMENTATION
//_________________________________________________________

//tainted_sinks(id) :- selfdestruct(id,id_taint), !trustedVariables(id,_,_).

derivesFrom(id_derived, id_taint) :- assign(id_derived,id_taint).
derivesFrom(id_derived, id_taint) :- uop(id_derived,id_taint,_).
derivesFrom(id_derived, id_taint) :- bop(id_derived,id_taint,_,_).
derivesFrom(id_derived, id_taint) :- bop(id_derived,_,id_taint,_).
derivesFrom(id_derived, id_taint) :- branch(_,_,_,id_block,_,id_taint), blockStmt(id_block, id_derived). // implicit dependency
derivesFrom(id_derived, id_taint) :- branch(_,_,_,_,id_block,id_taint), blockStmt(id_block, id_derived). // implicit dependency
derivesFrom(id_derived, id_taint) :- goto(id_transfer,_,id_block_to), transferArgument(id_transfer,id_taint,index), argument(id_derived,id_block_to,index). // derivation through arguments after a goto (after a branch)
derivesFrom(id_derived, id_taint) :- selfdestruct(id_derived, id_taint).
derivesFrom(id_derived, id_taint) :- derivesFrom(id_intermediary, id_taint), derivesFrom(id_derived, id_intermediary).

contextSenderChain(new_ctxt, old_ctxt) :- containsSender(new_ctxt, old_ctxt).
contextSenderChain(new_ctxt, old_ctxt) :- containsSender(new_ctxt, ctxt), contextSenderChain(ctxt, old_ctxt).

blockChain(return_block, return_block) :- return(_,return_block).
blockChain(return_block, return_block) :- revert(_,return_block).
blockChain(return_block, entry_block) :- blockChain(return_block, block), jump(_,entry_block,_,block).
blockChain(return_block, entry_block) :- blockChain(return_block, block), goto(_,entry_block,block).
blockChain(return_block, entry_block) :- blockChain(return_block, block), branch(_,_,entry_block,block,_,_).
blockChain(return_block, entry_block) :- blockChain(return_block, block), branch(_,_,entry_block,_,block,_).

containsSender(id_stmt, "000") :- builtinVariable(id_stmt,"SENDER"). //"000" stands for "in all contexts"
containsSender(id_derived, ctxt) :- containsSender(ctxt,_), transferArgument(id_transfer, ctxt, index), jump(id_transfer,_,id_block_to,_), argument(id_derived, id_block_to, index). //function call when the argument depends on msg.sender
containsSender(id_derived, ctxt) :- contextSenderChain(ctxt,ctxt_previous), transferArgument(id_transfer_return, ctxt, index), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer_jump,_,id_block_entry,id_block_next), transferArgument(id_transfer_jump, ctxt_previous,_), argument(id_derived, id_block_next, index). // return after a function call: if the result value depends on msg.sender, then the block to which we return to knows it. `blockChain`is necessary as shown on example `transferSender.sol`
containsSender(id_derived, ctxt) :- containsSender(ctxt,"000"), transferArgument(id_transfer_return, ctxt, index), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer_jump,_,id_block_entry,id_block_next), transferArgument(id_transfer_jump, ctxt_previous,_), argument(id_derived, id_block_next, index). // same as above but the return value depends on msg.sender independently of the function input
containsSender(id_derived, ctxt) :- derivesFrom(id_derived,id_taint), containsSender(id_taint, ctxt).



trustedVariables(id_stmt, "000") :- const(id_stmt,_).
trustedVariables(id_stmt, ctxt) :- assign(id_stmt,id_stmt_before), trustedVariables(id_stmt_before, ctxt).
trustedVariables(id_stmt, ctxt) :- uop(id_stmt,id_stmt_before,_), trustedVariables(id_stmt_before, ctxt).
trustedVariables(id_stmt, ctxt) :- bop(id_stmt,id_stmt_before_1,id_stmt_before_2,_), trustedVariables(id_stmt_before_1, ctxt), trustedVariables(id_stmt_before_2, ctxt).
trustedVariables(id_stmt, ctxt) :- store(id_stmt,_,id_stmt_before), trustedVariables(id_stmt_before, ctxt).
//trustedVariables(id_stmt, ctxt) :- trustedVariables(ctxt,_), transferArgument(id_transfer, ctxt, index), jump(id_transfer,_,id_block_to,_), argument(id_stmt, id_block_to, index).
//TODO: add what come from trusted state variables
//TODO: everything should be only in trusted blocks
// trustedVariables(id_stmt, ctxt) :- load(id_stmt,field), !untrustedStateVariables(field), allPossibleContexts(id_stmt,ctxt).
//trustedVariables(id_stmt, ctxt) :- allPossibleContexts(id_stmt,ctxt), !untrustedVariables(id_stmt, ctxt).

// contextUntrustedVariablesChain(new_ctxt, old_ctxt) :- untrustedVariables(new_ctxt, old_ctxt).
// contextUntrustedVariablesChain(new_ctxt, old_ctxt) :- untrustedVariables(new_ctxt, ctxt), contextUntrustedVariablesChain(ctxt, old_ctxt).

// untrustedVariables(id_stmt, "000") :- builtinVariable(id_stmt,_). //"000" stands for "in all contexts"
// untrustedVariables(id_stmt, "000") :- argument(id_stmt,id_block,_), function(id_block,_).
// untrustedVariables(id_derived, ctxt) :- untrustedVariables(ctxt,_), transferArgument(id_transfer, ctxt, index), jump(id_transfer,_,id_block_to,_), argument(id_derived, id_block_to, index). //function call when the argument depends on msg.sender
// untrustedVariables(id_derived, ctxt) :- contextUntrustedVariablesChain(ctxt,ctxt_previous), transferArgument(id_transfer_return, ctxt, index), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer_jump,_,id_block_entry,id_block_next), transferArgument(id_transfer_jump, ctxt_previous,_), argument(id_derived, id_block_next, index). // return after a function call: if the result value depends on msg.sender, then the block to which we return to knows it. `blockChain`is necessary as shown on example `transferSender.sol`
// untrustedVariables(id_derived, ctxt) :- untrustedVariables(ctxt,"000"), transferArgument(id_transfer_return, ctxt, index), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer_jump,_,id_block_entry,id_block_next), transferArgument(id_transfer_jump, ctxt_previous,_), argument(id_derived, id_block_next, index). // same as above but the return value depends on msg.sender independently of the function input
// untrustedVariables(id_derived, ctxt) :- derivesFrom(id_derived,id_taint), untrustedVariables(id_taint, ctxt).
// //TODO: add what come from untrusted state variables
// //TODO: everything should be only in unstrusted blocks


allPossibleContexts(id_stmt,"000") :- blockStmt(id_block,id_stmt), function(id_block,_). // when the statement is in a user-callable function
allPossibleContexts(id_stmt,ctxt) :- blockStmt(id_block,id_stmt), transferArgument(id_transfer, ctxt, _), jump(id_transfer,_,id_block_entry,_), blockChain(id_block_return, id_block_entry), blockChain(id_block_return, id_block). // when the statement is called by another function
allPossibleContexts(id_stmt,ctxt) :- blockStmt(id_block,id_stmt), transferArgument(id_transfer_return, ctxt, _), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer,_,id_block_entry,id_block_entry_1), blockChain(id_block_return_1, id_block_entry_1), blockChain(id_block_return_1, id_block). // when the statement is called after another called function has returned
allPossibleContexts(id_stmt,"000") :- blockStmt(id_block,id_stmt), !transferArgument(id_transfer_return,_,_), return(id_transfer_return,id_block_return), blockChain(id_block_return, id_block_entry), jump(id_transfer,_,id_block_entry,id_block_entry_1), blockChain(id_block_return_1, id_block_entry_1), blockChain(id_block_return_1, id_block), function(id_block_entry_2,_), blockChain(id_block_return_2, id_block). // when the statement is called after another called function that does not return

untrustedVariables(id_stmt, ctxt) :- allPossibleContexts(id_stmt,ctxt), !trustedVariables(id_stmt,ctxt).
untrustedVariables(id_stmt, ctxt) :- load(id_stmt,field), untrustedStateVariables(field), allPossibleContexts(id_stmt,ctxt).


untrustedStateVariables(field) :- store(_, field, id_attributed_stmt), untrustedVariables(id_attributed_stmt,_).

//_________________________________________________________
// OUTPUT
//_________________________________________________________

.output tainted_sinks
.output containsSender
.output argument
//.output contextSenderChain
.output blockChain
.output trustedVariables
// .output trustedStateVariables
// .output contextsOfStoredVariables
// .output stateVariableTrustStatus
.output untrustedVariables
.output untrustedStateVariables
.output allPossibleContexts